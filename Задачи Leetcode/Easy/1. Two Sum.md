Дан массив целых чисел `nums` и целое число `target`. Верните индексы этих двух чисел, сумма которых равна`target` .
Можно предположить, что для каждого входного значения существует **ровно одно решение** , и нельзя использовать один и тот же элемент дважды.
Вы можете вернуть ответ в любом порядке.
#flashcards
***
Классикой решения будет двойной проход по массиву `nums`.
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]
                    break
```
Такое решение займет [[O-большое|O(n ** 2)]], где `n` - длина массива `nums`.
***
Более правильным решением будет воспользоваться [[Хеш таблица|хеш-таблицей]].
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashf = {}
        for i in range(len(nums)):
            value = target - nums[i]
            if value in hashf:
                return [i, hashf[value]]
            else:
                hashf[nums[i]] = i
```
Здесь мы проходимся по всему массиву `nums` и ищем элемент в [[Словарь в Python|словаре]], который дополняет рассматриваемый элемент до `target`. Поиск по словарю занимает `O(1)`. Если разности нет, то добавляем элемент `nums` в словарь в надежде на то, что он дополнит какой-то последующий элемент до `target`.
В таком случае решение займет `O(n)`.